# Hash

해시는 해시함수를 이용해서 어떤 특정한 값으로 변환시킨다.

![image-20210307192036216](2%EC%A3%BC%EC%B0%A8_note.assets/image-20210307192036216.png)

이런 해시 기법을 이용하여, **해시테이블** / SHA(Secure Hash Algorithm) 암호화 / 데이터 압축에 사용 가능.

# Hash Table

해시를 이용하여 구현된 자료구조이다.

- Key -  Value 구조

- 빠른 연산 속도 ( 삽입, 삭제, 탐색 O(1) )

- 고정된 테이블 크기를 가지고 있으며, 해시함수로 인한 해시 충돌 발생 가능

  해시 충돌 발생시, 연산 속도는 O(N) 까지 느려질 수 있다.

- 적은 리소스 사용. 테이블로 나누어진 유한한 해시값! - 크기를 지정해놓아야하기 때문에 공간적으로 효율적이진 못하다.

## Hash Table의 동작

![img](2%EC%A3%BC%EC%B0%A8_note.assets/image.png)

Insertion, Deletion, Searching에서 O(1)의 속도를 가진다

> - 형성된 테이블에서 키를 받는다.
> - 키를 해싱하고 해당 해시 저장소에 간다.
> - 저장, 삽입, 탐색

실제로 탐색은 해싱이 이루어진 해시값을 찾아가는 탐색뿐으로 크기가 크든 작든 한번의 탐색이 이루어져 마치 배열과 같이 동작한다.

## Hash Table의 크기와 충돌

입력될 키의 갯수와 해시테이블 크기가 같으면 충돌문제가 발생하지 않으며, 이를 Direct address Table이라고 한다.

하지만 키를 모두 사용하지 않게 되면, 그만큼의 공간이 낭비하게 되므로 테이블의 크기는,  키의 개수보다 작게 만든다.

이렇게 생각한다면, 필연적으로 해시충돌은 일어날 수 밖에 없다는 이야기..

### 충돌을 해결하기 위한 방법

- Separate Chaning
  ![image-20210307193849316](2%EC%A3%BC%EC%B0%A8_note.assets/image-20210307193849316.png)

  동일한 해시값을 유지하고 해결하는 방식,

  내가 받은 해시값 이외에 접근이 불가한 **폐쇄 주소 형식**을 지닌다

  일반적으로 **LinkedList**로 구현한다

  Bucket은 리스트의 **포인터를 저장**하기 때문에 **별도의 메모리**를 사용해야함

  ~~값이 없다면 헤드로, 값이 있다면 헤드의 앞에 삽입?~~
  **균형 이진 탐색 트리**를 사용하면 한 해쉬값에 데이터가 아무리 많이 연결되어도 **O(logN)의 속도**를 보장할 수 있다.

  

- Open Addressing

- ![img](2%EC%A3%BC%EC%B0%A8_note.assets/image.png)

- 해시 충돌이 났을때 비어있는 해시를 찾는 방식이다
  John이 152번을 점유하고 있을때 Sandra에서 152번과 충돌이 나서 153번을 점유한다
  마찬가지로 Ted가 153번을 점유하려하는데 Sandra와 충돌이 나서 154번을 점유한다.

- 탐사의 종류에는 선형탐사, 제곱탐사, 이중해싱등이 있다.

- n+1번째 버킷을 찾아가는 Linear Probing(선형탐사)
  공간 지역성에 따른 캐싱에 유리하다
  ![img](2%EC%A3%BC%EC%B0%A8_note.assets/image.png)
  캐싱엔 분명히 유리하지만, Load factor(해시 테이블에서 버킷이 가득찬 확률)가 높아질 수록 효율이 급격하게 감소한다.
  일반적으로 Load Factor값은 0.75가 최적이라고 알려져있다고 합니다.

- 바로 옆의 값만 탐색하는데 한계를 느껴 제곱 수에 따라 탐색 수를 틀려나가는 방식도 존재하지만,

  초기 해쉬값이 같다면, 어짜피 다음 탐색 범위는 똑같이 중복이 일어날 수 밖에 없다...
  ![img](2%EC%A3%BC%EC%B0%A8_note.assets/image.png)

- 더블 해싱!
  선형탐색이나 제곱탐색이 규칙성을 가져서 문제가 일어난다는 것에 기인해서 탐색의 규칙성을 없애는 방식
  ![img](2%EC%A3%BC%EC%B0%A8_note.assets/image.png)

## 그럼 자바에서는?

Seperate chaning 방식을 채용하고 있다.

1. Open Addressing은 데이터의 개수가 적다면 Separate chaning보다 더 성능이 좋다. 하지만, 배열의 크기가 커질수록 연속된 공간에 데이터를 저장하여 캐시 효율이 높다는 장점이 사라지게 된다.
2. remove()의 호출 빈도에 따라서도 다른 효율을 보여주는데, **Separate chaning이 Linked list방식**을 채택하고 있기때문에, 
   remove()의 호출이 잦아진다면 더 높은 효율을 보여준다

## HashMap과 HashTable

HashTable과 HashMap은 같이 Map인터페이스를 구현하고 있기때문에 제공하는 기능은 같다.

하지만 HashMap은 보조 해시 함수 (Additional Hash Function)을 사용하기 때문에, 보조 해시 함수를 사용하지 않는 HashTable에 비해서 해시 충돌이 덜 발생할 수 있어 상대적으로 성능상 이점이 있다

> 보조 해시 함수(supplement hash function)의 목적은 '키'의 해시 값을 변형하여, 해시 충돌 가능성을 줄이는 것이다. 이 보조 해시 함수는 JDK 1.4에 처음 등장했다. Java 5 ~ Java 7은 같은 방식의 보조 해시 함수를 사용하고, Java 8부터는 다시 새로운 방식의 보조 해시 함수를 사용하고 있다.
>
> Java 8 HashMap 보조 해시 함수는 상위 16비트 값을 XOR 연산하는 매우 단순한 형태의 보조 해시 함수를 사용한다. 이유로는 두 가지가 있는데, 첫 번째는 Java 8에서는 해시 충돌이 많이 발생하면 링크드 리스트 대신 트리를 사용하므로 해시 충돌 시 발생할 수 있는 성능 문제가 완화되었기 때문이다. 두 번째로는 최근의 해시 함수는 균등 분포가 잘 되게 만들어지는 경향이 많아, Java 7까지 사용했던 보조 해시 함수의 효과가 크지 않기 때문이다. 두 번째 이유가 좀 더 결정적인 원인이 되어 Java 8에서는 보조 해시 함수의 구현을 바꾸었다.

# Hash Map

- Key : Value는 매핑 된다.
- Key는 유니크하다.
- Key와 Value를 저장할 수 있다.
- Key를 통해 Value를 알 수 있다.
- Key를 통해 새 Value로 변경할 수 있다.
- Key를 통해 Value를 삭제할 수 있다.
  



참고 : 
https://velog.io/@agugu95/Hash-Table-Java-HashMap
http://egloos.zum.com/iilii/v/4457500
https://odol87.tistory.com/4